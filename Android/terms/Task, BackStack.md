# Task, BackStack
앱은 보통 여러 개의 액티비티로 구성된다. 각 액티비티는 특정한 목적을 갖는 화면을 보여주며, 다른 액티비티들을 실행할 수 있다. 예를 들어, 이메일 앱은 읽지 않은 이메일 목록을 보여주는 액티비티가 있으며, 목록에서 이메일을 선택하면 그 이메일 내용을 보여주는 액티비티도 있다.

액티비티는 디바이스에 설치된 다른 앱의 액티비티도 실행할 수 있다. 예를 들어, 내 앱에서 이메일 보내기가 되도록하고 싶다면, Intent.ACTION_SEND 액션값과 이메일 주소 및 메세지를 담고 있는 인텐트를 만들어서 실행하면 된다. 그러면 디바이스에 설치된 모든 앱 중에서 해당 인텐트에 대응되는, 즉, 이메일을 비롯한 데이터를 보내는 기능을 수행하는 액티비티가 실행될 것이다. 만약 그러한 액티비티가 2개 이상이라면 사용자가 선택할 수 있도로고 다이얼로그를 띄어준다. 이메일 보내기 작업이 완료되면 이메일 쓰기 액티비티가 종료되면서 내 앱의 액티비티가 다시 resumed 상태가 되는데, 이는 마치 이메일 쓰기 액티비티가 내 앱의 일부인 것처럼 보이게 한다. 이러한 경우, 비록 액티비티들이 서로 다른 앱에 속해 있긴 하지만, 같은 태스크에 있음으로써 사용자에게 자연스러운 UX를 제공할 수 있는 것이다.

## Task란?
* 사용자에 의해 실행된 액티비티들의 모음
* 액티비티들은 생성되면서 "백스택" 이라 불리는 스택에 쌓이게 됨

디바이스의 홈 화면은 거의 머든 태스크들의 시작점이다. 사용자가 앱 런처에서 앱 아이콘을 터치하거나, 홈 화면의 바로가기 아이콘을 터치하면, 앱의 태스크가 전면(foreground)로 나오게 된다. 만약 앱을 최근에 실행한 적이 없어서 태스크가 없다면, 새 태스크가 생성되며 앱의 "메인" 액티비티가 실행되고 태스크의 root가 된다.

현재 액티비티가 다른 액티비티를 실행하면, 실행된 새 액티비티가 스택의 top에 들어가면서 포커스를 획득하며, 이전 액티비티는 여전히 스택에 들어가 있기는 하지만, stopped 상태가 된다. 액티비티가 정지되더라도(stop), 시스템은 액티비티의 사용자 인터페이스(UI)의 현재 상태를 보존하며, 사용자가 뒤로가기 버튼을 눌렀을 때, 현재의 액티비티를 스택에서 꺼내고(popped, 이때 액티비티는 종료된다.), 이전 액티비티를 resumed 상태로 만든다.(정지되기전 UI 상태가 복구됨). 스택에 있는 액티비티의 배열은 절대 바뀌지 않는다. 단지 스택에 넣고(PUSH) 꺼내는 (POP) 동작만 있을 뿐이다. 액티비티가 생성될 때 스택에 넣고, 사용자가 뒤로가기 버튼을 눌러서 종료될 때 꺼내는 것이다. 이러한 백스택의 자료구조를 "LAST IN, FIRST OUT" LIFO(후입선출)이라고 표현한다. 아래 그림은 액티비티들이 백스택에 어떻게 들어가고 나오는지를 보여준다.

![image](https://user-images.githubusercontent.com/91411447/161181194-258c18d7-27ed-4076-84b9-8a987a6d7b2a.png)

태스크의 새 액티비티가 백스택에 어떻게 추가되는지와, 뒤로가기 버튼을 눌렀을 때 현재 액티비티가 종료되며 이전 액티비티가 다시 resumed 상태가 되는 것을 보여준다.

만약 사용자가 계속 뒤로가기 버튼을 누른다면, 스택의 top에 있는 액티비티가 제거되면서 이전 액티비티가 resumed 상태로 스택의 top이 될 것이고, 결국은 홈 화면으로 빠져나갈 것이다.(또는 해당 태스크가 시작되기 전의 마지막 액티비티가 실행될 것이다.) 태스크의 모든 액티비티가 제거되면, 그 태스크도 없어진
다.

![image](https://user-images.githubusercontent.com/91411447/161181379-5109c4f6-78ce-401f-bd49-49834ec227b5.png)

Task B는 foreground에서 사용자와 상호작용을 하지만, Task A는 background에서 다시 resumed 상태가 되기를 기다린다.

Task는 사용자가 다른 태스크를 시작하거나, 홈 버튼을 눌러서 홈 화면으로 전환될 때, background로 이동한다. background에 있을 때, 태스크의 모든 액티비티들은 stopped 상태가 되지만, 태스크의 백스택은 액티비티들을 잘 유지하며, 위 사진과 같이 다른 태스크에게 자리를 내주고 포커스만 잃게 되는 것이다. 태스크는 다시 foreground로 나설 수 있으며, 사용자는 해당 태스크의 마지막 화면을 볼 수 있다. 예를 들어, 현재 태스크(Task A)가 스택에 3개의 액티비티를 담고 있는데, 사용자가 홈 버튼을 눌러 홈 화면으로 이동한 후 앱 런처에서 다른 앱을 실행한다고 가정해보자. 홈 화면으로 이동할 때, Task A는 background로 이동한다. 그리고 다른 앱을 실행할 때, 시스템은 그 앱의 태스크인 Task B를 시작하는데 그것은 자신의 액티비티들을 담을 스택을 따로 갖는다. 그 앱에서 사용자가 할 일을 마치고 홈 화면으로 돌아왔다가 다시 이전의 앱을 실행하면, Task A가 다시 foreground로 나올 것이며, 스택에 있던 3개의 액티비티는 모두 무사하고, 스택의 top에 있는 액티비티(사용자가 Task A에서 마지막으로 실행한 액티비티)가 다시 resumed 상태로 될 것이다. 홈 화면으로 이동할 때, Task B는 background로 이동한다. 이전 태스크를 다시 전면으로 가져오는 방법은 해당 앱의 아이콘을 클릭하거나, 홈 버튼을 길게 누르면 보이는 최근 태스크 목록에서 태스크를 선택하면 된다. 이것은 안드로이드 멀티태스킹의 한 예이다.
여러 개의 태스크가 동시에 background에 있을 수 있긴 하지만, 메모리가 부족할 경우 시스템이 메모리를 회복하기 위해 백그라운드에 있는 태스크의 액티비티들을 종료할 수도 있다.

![image](https://user-images.githubusercontent.com/91411447/161182138-1e5db1ad-8f63-48ad-a70f-c53478cb20da.png)

하나의 액티비티가 여러 개의 서로 다른 객체로 생성될 수 있다.

백스택의 액티비티들은 절대 재배치되지 않기 때문에, 만약 내 앱에서 특정 액티비티가 여러 개의 다른 액티비티로부터 실행될 수 있다면, 그 액티비티는 생성될 때마다 새로운 객체로 스택에 추가될 것이다.(기본적으로, 스택에 있는 동일한 액티비티의 객체를 재사용하지 않는다.), 위 그림에서 보이는 바와 같이 하나의 액티비티가 여러 번 객체로 생성될 수 있다.


### <activity> 요소의 주요 속성들
* taskAffinity
* launchMode
* allowTaskReparenting
* clearTaskOnLaunch
* alwaysRetainTaskState
* finishOnTaskLaunch
  
### Intent flags 속성
* FLAG_ACTIVITY_NEW_TASK
* FLAG_ACTIVITY_CLEAR_TOP
* FLAG_ACITIVTY_SINGLE_TOP

### Defining Lauch Mode
launch mode 정의에는 2가지 방식이 있다.
* 매니페스트 파일 사용
  * 패니페스트 파일에 액티비티를 선언할 때, 액티비티 생성 시 태스크에 어떻게 속하게 될지 지정할 수 있다.
* 인텐트 플래그 사용
  * 소스코드에서 startActivity()를 호출할 때, 인텐트 플래그를 추가함으로써 액티비티가 태스크에 어떻게 속하게 될지 지정할 수 있다.
  액티비티 A가 액티비티 B를 실행하는 경우, 인텐트 플래그를 추가함으로써 액티비티가 태스크에 어떻게 속하게 될지를 지정할 수 있다.
  
  액티비티 A가 액티비티 B를 실행하는 경우, 액티비티 B는 매니페스트 파일에 속성을 추가함으로써 자신이 현재 태스크에 어떻게 속하게 될지를 지정할 수 있고, 액티비티 A는 액티비티 B를 실행하는 인텐트에 플래그를 추가함으로써 역할을 할 수 있다. 이 둘은 모두 액티비티 B와 태스크의 관계를 지정하는 것이며, 액티비티 A의 인텐트 실행히 액티비티 B의 매니페스트 파일 지정보다 우선시한다.
  
### 4가지 launchMode
* standard(default)
  시스템은 액티비티를 실행하려고 인텐트를 넘겨주고 있는 그 태스크에서 액티비티의 새 객체를 생성한다. 액티비티는 여러 번 객체를 생성할 수 있고, 각각은 서로 다른 태스크에 들어갈 수도 있으며, 하나의 태스크가(한 액티비티에 대한) 여러 개의 객체를 포함할 수 있다.
* singleTop
  어떤 액티비티의 객체가 이미 현재 테스크의 top에 있는데 그 액티비티에 대하여 startActivity()를 호출할 경우, 시스템은 액티비티의 새 객체를 생성하는 대신에 태스크의 top에 있는 액티비티 객체의 onNewIntent()를 호출함으로써 재사용한다. standard와 마찬가지로, 액티비티는 여러 번 객체를 생성할 수 있고, 각각은 서로 다른 태스크에 들어갈수도 있으며, 하나의 태스크가(한 액티비티에 대한) 여러 개의 객체를 포함할 수 있다. 하지만, 태스크의 top에 하나의 액티비티에 대한 2개의 객체가 들어가는 상황만은 허용하지 않으며, 이미 있는 객체를 재사용하도록 하는 것이다.
  
  예를 들어, 태스크의 백스택이 A, B, C, D라는 액티비티로 채워져있다고 가정해보면(스택은 A-B-C-D이며, D가 top). 그리고 시스템에게 D를 실행해달라는 인텐트가 왔다고 하자. 만약 D의 시작모드(launchMode)가 "standard"라면, D의 새 객체가 생성되어 백스택에 추가되고 스택은 A-B-C-D-D가 될 것이다. 하지만 D의 시작모드가 "singleTop"이라면, 백스택의 top에 이미 D의 객체가 있기 때문에 그 객체가 onNewIntent()를 통해 해당 인텐트를 받을 것이고 스택은 그대로 A-B-C-D 가 될 것이다. 하지만 시작되는 액티비티가 D가 아닌 B라면 시작모드가 "singleTop"이라 하더라도, 새 객체가 생성되어 백스택에 추가될 것이고 스택은 A-B-C-D-B가 될 것이다.

(**액티비티의 새 객체가 생성되어 태스크에 추가되었을 때, 사용자가 뒤로가기 버튼을 누르면 이전 액티비티로 돌아갈 수 있었다. 그러나 시작 모드가 "singleTop"이라서 태스크의 top에 있는 액티비티가 재사용된 상황이라면, 사용자가 뒤로가기 버튼을 눌렀을 때, 재사용되기 전 상태로 돌아가는 것이 아니라, 현재 액티비티가 종료되고 그 이전의 액티비티가 재시작 될 것이다.)

* singleTask
  시스템은 새 태스크를 생성하고, 태스크의 root에 액티비티의 새 객체를 생성한다. 하지만, 태스크에 이미 해당 액티비티의 객체가 존재한다면, 액티비티의 새 객체를 생성하지 않고 기존 객체의 onNewIntent()를 호출함으로써 재사용한다. 하나의 액티비티에 대한 객체는 오직 하나만 존재할 수 있다.
(시스템은 시작모드가 singleTask인 액티비티를 실행할 때 taskAffinity가 같은 태스크가 있는지를 확인하여, 만약 있다면 그 탯크에 액티비티의 객체를 생성하여 넣으며, 이 때의 위치는 태스크의 root가 아니다. 그리고 만약 taskAffinity가 같은 태스크가 없다면, 새 태스크를 생성하고 그 태스크의 root에 액티비티의 새 객체를 생성한다.

* singleInstance
  자신이 속한 태스크에 다른 액티비티의 객체들을 들어오지 못하게 한다는 점을 제외하고는 "singleTask"와 비슷하다. 하나의 액티비티에 대한 객체는 오직 하나이고, 자신이 속한 태스크에는 오직 자신만 있을 뿐이다. 이 액티비티에서 다른 액티비티를 실행한다면, 실행된 액티비티는 다른 태스크에 속하게 된다.
  
  다른 예로, 인터넷 브라우저 앱은 브라우저 액티비티 시작 모드를 singleTask로 지정했기 때문에, 내 앱에서 브라우저를 실행할 때 브라우저 액티비티가 내 앱의 태스크에 들어가지 않는다. 대신에 새 태스크를 생성하거나, 이미 존재하는 브라우저의 태스크가 background에 있다면 foreground로 가져와서 재사용한다. 액티비티가 새 태스크에 들어갔건, 기존의 태스크에 들어갔건 상관없이 사용자가 뒤로가기 버튼을 누르면 현재 액티비티가 종료되고 이전 액티비티가 실행된다. 하지만, 시작 모드가 singleTask인 액티비티를 실행하는데, 그 액티비티는 이미 background에 있는 태스크에 존재하고 그 태스크에는 다른 액티비티도 있는 경우, 시스템은 background에 있던 태스크를 통째로 foreground로 가져온다. 이때, 현재의 백스택의 top에 background에서 가져온 태스크의 액티비티들을 모두 집어 넣는다. 아래 그림은 이 과정을 보여준다.
  
![image](https://user-images.githubusercontent.com/91411447/161185267-f377e748-1cc4-4ed9-8f5f-9dc3cf948f3f.png)
  
시작 모드가 "singleTask"인 액티비티를 백스택에 추가하는 모습을 보여준다. 만약 액티비티가 background에 있는 다른 태스크에 이미 존재한다면, 그 태스크가 통째로 현재의 태스크의 top으로 옮겨오게 된다.
  (매니페스트 파일에서 지정한 launchMode는, 액티비티를 실행할 때 넘겨주는 인텐트에 포함된 플래그값으로 덮어씌워질 수 있다. 다시 말해, 인텐트에 포함된 플래그 값이 매니페스트 파일에 지정된 시작모드보다 우선하다.)
  
### Intent flags
* FLAG_ACTIVITY_NEW_TASK
  실행하려는 액티비티의 객체가 존재하지 않으면 새 태스크의 root에 액티비티의 새 객체가 들어간다. 하지만 background에 이미 그 액티비티를 담고 있는 태스크가 있다면, foreground로 가져와서 마지막 상태를 복구하고 인텐트를 onNewIntent()에 넘겨준다. 하지만 background에 있던 태스크의 top에 있던 액티비티가 실행되기 때문에, 실행하고자 했던 액티비티와 실행된 액티비티가 다를 수도 있다. 따라서 대부분의 경우 FLAG_ACTIVITY_CLEAR_TOPO과 함께 사용한다.
  
  이것은 (FLAG_ACTIVITY_NEW_TASK + FLAG_ACTIVITY_CLEAR_TOP) 위에서 학습한 "singleTask"의 역할과 같다.
* FLAG_ACTIVITY_SINGLE_TOP
  현재 실행중인 액티비티(현재 태스크의 top에 있는)에서 다실 동일한 액티비티를 실행하려고 하는 경우, 새 객체를 생성하는 대신 현재 액티비티의 onNewIntent()를 호출함으로써 액티비티를 재사용한다. 이것은 위에서 학습한 "singleTop"의 역할과 같다.
* FLAG_ACTIVITY_CLEAR_TOP
  만약 실행하려고 하는 액티비티의 객체가 이미 현재 태스크에 존재한다면, 새 객체를 생성하는 대신, 그 액티비티 객체의 위에 있는 다른 액티비티들을 모두 제거하여 그 택티비티가 태스크의 top이 되도록 한다. 이것과 역할이 같은 launchMode 값은 없다.
  
  다시 말하지만, FLAG_ACTIVITY_CLEAR_TOP 은 대부분의 경우 FLAG_ACTIVITY_NEW_TASK 와 함께 사용된다. 이 경우, 실행하려고 하는 액티비티가 background에 있는 태스크에 존재한다면, 그 태스크를 foreground로 가져오고, 해당 액티비티 위에 다른 액티비티들이 있다면 모두 제거하여 그 액티비티가 실행되도록 한다.
***
출처: https://www.notion.so/Tasks-and-Back-Stack-2ac785bab38d442b92b8dc4b1b4287fe
